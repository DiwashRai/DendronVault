{"pageProps":{"note":{"id":"hfzytsqavasmhor93hprfkn","title":"Variant","desc":"","updated":1690039148273,"created":1690037287432,"custom":{},"fname":"lang.cpp.std.variant","type":"note","vault":{"fsPath":".","selfContained":true,"name":"DendronVault"},"contentHash":"292da5b40e14c8d0da88fe82d0671932","links":[],"anchors":{"summary":{"type":"header","text":"Summary","value":"summary","line":8,"column":0,"depth":3},"typical-usage":{"type":"header","text":"Typical usage","value":"typical-usage","line":18,"column":0,"depth":3},"database-query-results":{"type":"header","text":"database query results","value":"database-query-results","line":20,"column":0,"depth":4},"abstract-syntax-tree":{"type":"header","text":"Abstract syntax tree","value":"abstract-syntax-tree","line":31,"column":0,"depth":4},"examples":{"type":"header","text":"Examples","value":"examples","line":36,"column":0,"depth":3},"basic-usage":{"type":"header","text":"Basic usage","value":"basic-usage","line":38,"column":0,"depth":4},"stdbad_variant_access":{"type":"header","text":"std::bad_variant_access","value":"stdbad_variant_access","line":51,"column":0,"depth":4},"stdget_if":{"type":"header","text":"std::get_if","value":"stdget_if","line":62,"column":0,"depth":4},"stdholds_alternative":{"type":"header","text":"std::holds_alternative","value":"stdholds_alternative","line":73,"column":0,"depth":4}},"children":[],"parent":"vs1fiq1wm14sf0cqq4ok5vj","data":{}},"body":"<h1 id=\"variant\">Variant<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#variant\"></a></h1>\n<h3 id=\"summary\">Summary<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#summary\"></a></h3>\n<p><code>std::variant</code> is a type-safe union and was added as part of C++17. It's a class template that can\nhold values of different types but only one at a time. It is similar to <code>std::any</code> but it can only\nhold types that are specified in the template parameters.</p>\n<p>Before <code>std::variant</code>, developers would use unions to hold different types. However, unions are\nunsafe because they don't keep track of the type of the value they hold. This means that you can\naccidentally read the wrong type of value from a union. <code>std::variant</code> solves this problem by\nkeeping track of the type of the value it holds.</p>\n<h3 id=\"typical-usage\">Typical usage<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#typical-usage\"></a></h3>\n<h4 id=\"database-query-results\">database query results<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#database-query-results\"></a></h4>\n<p>consider a function that performs a database query. It might return the query results on success,\nan error message on failure, or a boolean value indicating no results found. This function could\nreturn a std::variant holding either query results, a string, or a boolean.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>variant<span class=\"token operator\">&#x3C;</span>QueryResults<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span><span class=\"token operator\">></span> <span class=\"token function\">query_db</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token operator\">&#x26;</span> query<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"abstract-syntax-tree\">Abstract syntax tree<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#abstract-syntax-tree\"></a></h4>\n<p>Another typical usage of std::variant is to hold different kinds of nodes in a tree-like data\nstructure, like an abstract syntax tree (AST) in a compiler. Each node could be a different\nstd::variant representing different types of statements or expressions in the language.</p>\n<h3 id=\"examples\">Examples<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#examples\"></a></h3>\n<h4 id=\"basic-usage\">Basic usage<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#basic-usage\"></a></h4>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&#x3C;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&#x3C;variant></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>variant<span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n  v <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n  v <span class=\"token operator\">=</span> <span class=\"token number\">3.14f</span><span class=\"token punctuation\">;</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"stdbad_variant_access\">std::bad_variant_access<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stdbad_variant_access\"></a></h4>\n<p>Calling <code>std::get</code> with the wrong type will throw a <code>std::bad_variant_access</code> exception.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>variant<span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>bad_variant_access<span class=\"token operator\">&#x26;</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">what</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"stdget_if\">std::get_if<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stdget_if\"></a></h4>\n<p>Use <code>std::get_if</code> to get a pointer to the value held by a variant.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>variant<span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> pval <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get_if</span><span class=\"token generic class-name\"><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">&#x26;</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token operator\">*</span>pval <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token string\">\"v does not hold an int\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"stdholds_alternative\">std::holds_alternative<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stdholds_alternative\"></a></h4>\n<p>You can use <code>std::holds_alternative</code> to check if a variant holds a specific type.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>variant<span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">holds_alternative</span><span class=\"token generic class-name\"><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token string\">\"v holds an int\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&#x3C;&#x3C;</span> <span class=\"token string\">\"v does not hold an int\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>","noteIndex":{"id":"txvdlk2mbhl2y2muokxxozo","title":"Root","desc":"","updated":1664676002873,"created":1664671276173,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"DendronVault"},"contentHash":"896d57ab408d13d6cce66d3360a4c1be","links":[],"anchors":{"quick-access":{"type":"header","text":"Quick access","value":"quick-access","line":8,"column":0,"depth":2}},"children":["akgpjs39sueidxnil3k1feg","cq5doh4f24evc4ewzhg5yf3","3xtbw7nonlogrlsu9k2hymz","lubegqfiz1ik4hq8fnomek2","uhd2kqv69ly9jb7r0o6dw1t","155oput5ed55eq5lxuswdw9","rftnddr5kr2oi9582nrwjxd","nm541dgoi0njzxnux7it18y","5fs80ws2li1d12hstqngu4h"],"parent":null,"data":{},"body":"\n## Quick access\n\n- [C++ STL]([[lang.cpp.std]])"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"DendronVault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","assetsPrefix":"/DendronVault","siteUrl":"https://diwashrai.github.io","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}